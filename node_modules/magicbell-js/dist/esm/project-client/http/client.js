import { RequestHandlerChain } from './handlers/handler-chain.js';
import { HookHandler } from './handlers/hook-handler.js';
import { RequestValidationHandler } from './handlers/request-validation-handler.js';
import { ResponseValidationHandler } from './handlers/response-validation-handler.js';
import { RetryHandler } from './handlers/retry-handler.js';
import { TerminatingHandler } from './handlers/terminating-handler.js';
import { CustomHook } from './hooks/custom-hook.js';
import { isRequestCursorPagination } from './transport/types.js';
export class HttpClient {
    constructor(config, hook = new CustomHook()) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: config
        });
        Object.defineProperty(this, "requestHandlerChain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new RequestHandlerChain()
        });
        this.requestHandlerChain.addHandler(new ResponseValidationHandler());
        this.requestHandlerChain.addHandler(new RequestValidationHandler());
        this.requestHandlerChain.addHandler(new RetryHandler());
        this.requestHandlerChain.addHandler(new HookHandler(hook));
        this.requestHandlerChain.addHandler(new TerminatingHandler());
    }
    call(request) {
        return this.requestHandlerChain.callChain(request);
    }
    async *stream(request) {
        yield* this.requestHandlerChain.streamChain(request);
    }
    async callPaginated(request) {
        const response = await this.call(request);
        if (!response.data) {
            throw new Error('no response data to paginate through');
        }
        const page = this.getPage(request, response.data);
        return {
            ...response,
            data: page,
        };
    }
    async callCursorPaginated(request) {
        const response = await this.call(request);
        if (!response.data) {
            throw new Error('no response data to paginate through');
        }
        const page = this.getPage(request, response.data);
        const nextCursor = this.getNextCursor(request, response.data);
        return {
            ...response,
            data: page,
            nextCursor,
        };
    }
    setBaseUrl(url) {
        this.config.baseUrl = url;
    }
    setConfig(config) {
        this.config = config;
    }
    getPage(request, data) {
        var _a;
        if (!request.pagination) {
            throw new Error('getPage called for request without pagination property');
        }
        let curr = data;
        for (const segment of request.pagination.pagePath || []) {
            curr = curr[segment];
        }
        const page = (_a = request.pagination.pageSchema) === null || _a === void 0 ? void 0 : _a.parse(curr);
        if (!page) {
            throw new Error(`error getting page data. Curr: ${JSON.stringify(curr)}. PagePath: ${request.pagination.pagePath}. Data: ${JSON.stringify(data)}`);
        }
        return page;
    }
    getNextCursor(request, data) {
        var _a, _b;
        if (!isRequestCursorPagination(request.pagination)) {
            return undefined;
        }
        let curr = data;
        for (const segment of request.pagination.cursorPath) {
            if (curr === null || curr === undefined) {
                return null;
            }
            curr = curr[segment];
        }
        return (_b = (_a = request.pagination.cursorSchema) === null || _a === void 0 ? void 0 : _a.parse(curr)) !== null && _b !== void 0 ? _b : null;
    }
}
//# sourceMappingURL=client.js.map