import { z } from 'zod';
import { Environment } from '../../http/environment.js';
import { RequestBuilder } from '../../http/transport/request-builder.js';
import { ContentType } from '../../http/types.js';
import { BaseService } from '../base-service.js';
import { apnsConfigCollectionResponse } from './models/apns-config-collection.js';
import { apnsConfigPayloadRequest, apnsConfigPayloadResponse, } from './models/apns-config-payload.js';
import { eventSourceConfigCollectionResponse, } from './models/event-source-config-collection.js';
import { eventSourceConfigPayloadRequest, eventSourceConfigPayloadResponse, } from './models/event-source-config-payload.js';
import { expoConfigCollectionResponse } from './models/expo-config-collection.js';
import { expoConfigPayloadRequest, expoConfigPayloadResponse, } from './models/expo-config-payload.js';
import { fcmConfigCollectionResponse } from './models/fcm-config-collection.js';
import { fcmConfigPayloadRequest, fcmConfigPayloadResponse } from './models/fcm-config-payload.js';
import { githubConfigCollectionResponse } from './models/github-config-collection.js';
import { githubConfigPayloadRequest, githubConfigPayloadResponse, } from './models/github-config-payload.js';
import { inboxConfigCollectionResponse } from './models/inbox-config-collection.js';
import { inboxConfigPayloadRequest, inboxConfigPayloadResponse, } from './models/inbox-config-payload.js';
import { integrationConfigCollectionResponse, } from './models/integration-config-collection.js';
import { mailgunConfigCollectionResponse } from './models/mailgun-config-collection.js';
import { mailgunConfigPayloadRequest, mailgunConfigPayloadResponse, } from './models/mailgun-config-payload.js';
import { pingConfigCollectionResponse } from './models/ping-config-collection.js';
import { pingConfigPayloadRequest, pingConfigPayloadResponse, } from './models/ping-config-payload.js';
import { sendgridConfigCollectionResponse } from './models/sendgrid-config-collection.js';
import { sendgridConfigPayloadRequest, sendgridConfigPayloadResponse, } from './models/sendgrid-config-payload.js';
import { sesConfigCollectionResponse } from './models/ses-config-collection.js';
import { sesConfigPayloadRequest, sesConfigPayloadResponse } from './models/ses-config-payload.js';
import { slackBotConfigCollectionResponse } from './models/slack-bot-config-collection.js';
import { slackBotConfigPayloadRequest, slackBotConfigPayloadResponse, } from './models/slack-bot-config-payload.js';
import { slackConfigCollectionResponse } from './models/slack-config-collection.js';
import { slackConfigPayloadRequest, slackConfigPayloadResponse, } from './models/slack-config-payload.js';
import { smtpConfigRequest, smtpConfigResponse } from './models/smtp-config.js';
import { smtpConfigObjectCollectionResponse, } from './models/smtp-config-object-collection.js';
import { stripeConfigCollectionResponse } from './models/stripe-config-collection.js';
import { stripeConfigPayloadRequest, stripeConfigPayloadResponse, } from './models/stripe-config-payload.js';
import { twilioConfigCollectionResponse } from './models/twilio-config-collection.js';
import { twilioConfigPayloadRequest, twilioConfigPayloadResponse, } from './models/twilio-config-payload.js';
import { webpushConfigCollectionResponse } from './models/webpush-config-collection.js';
import { webpushConfigPayloadRequest, webpushConfigPayloadResponse, } from './models/webpush-config-payload.js';
export class IntegrationsService extends BaseService {
    /**
     * Lists all available and configured integrations for the project. Returns a summary of each integration including its type, status, and basic configuration information.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<IntegrationConfigCollection>>} - OK
     */
    async listIntegrations(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: integrationConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current APNs integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ApnsConfigCollection>>} - OK
     */
    async listApnsIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/apns')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: apnsConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the APNs integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ApnsConfigPayload>>} - OK
     */
    async saveApnsIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/apns')
            .setRequestSchema(apnsConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: apnsConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the APNs integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteApnsIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/apns')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current EventSource integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<EventSourceConfigCollection>>} - OK
     */
    async listEventsourceIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/eventsource')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: eventSourceConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the EventSource integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<EventSourceConfigPayload>>} - OK
     */
    async saveEventsourceIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/eventsource')
            .setRequestSchema(eventSourceConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: eventSourceConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the EventSource integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteEventsourceIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/eventsource')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Expo integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ExpoConfigCollection>>} - OK
     */
    async listExpoIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/expo')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: expoConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Expo integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ExpoConfigPayload>>} - OK
     */
    async saveExpoIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/expo')
            .setRequestSchema(expoConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: expoConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Expo integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteExpoIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/expo')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current FCM integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<FcmConfigCollection>>} - OK
     */
    async listFcmIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/fcm')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: fcmConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the FCM integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<FcmConfigPayload>>} - OK
     */
    async saveFcmIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/fcm')
            .setRequestSchema(fcmConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: fcmConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the FCM integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteFcmIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/fcm')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current GitHub integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<GithubConfigCollection>>} - OK
     */
    async listGithubIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/github')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: githubConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the GitHub integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<GithubConfigPayload>>} - OK
     */
    async saveGithubIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/github')
            .setRequestSchema(githubConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: githubConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the GitHub integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteGithubIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/github')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Inbox integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<InboxConfigCollection>>} - OK
     */
    async listInboxIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/inbox')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: inboxConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Inbox integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<InboxConfigPayload>>} - OK
     */
    async saveInboxIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/inbox')
            .setRequestSchema(inboxConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: inboxConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Inbox integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteInboxIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/inbox')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current MagicBell SlackBot integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackBotConfigCollection>>} - OK
     */
    async listMagicbellSlackbotIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/magicbell_slackbot')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: slackBotConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the MagicBell SlackBot integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackBotConfigPayload>>} - OK
     */
    async saveMagicbellSlackbotIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/magicbell_slackbot')
            .setRequestSchema(slackBotConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: slackBotConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the MagicBell SlackBot integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteMagicbellSlackbotIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/magicbell_slackbot')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Mailgun integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<MailgunConfigCollection>>} - OK
     */
    async listMailgunIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/mailgun')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: mailgunConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Mailgun integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<MailgunConfigPayload>>} - OK
     */
    async saveMailgunIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/mailgun')
            .setRequestSchema(mailgunConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: mailgunConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Mailgun integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteMailgunIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/mailgun')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Ping Email integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<PingConfigCollection>>} - OK
     */
    async listPingEmailIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/ping_email')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: pingConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Ping Email integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<PingConfigPayload>>} - OK
     */
    async savePingEmailIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/ping_email')
            .setRequestSchema(pingConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: pingConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Ping Email integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deletePingEmailIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/ping_email')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current SendGrid integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SendgridConfigCollection>>} - OK
     */
    async listSendgridIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/sendgrid')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: sendgridConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the SendGrid integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SendgridConfigPayload>>} - OK
     */
    async saveSendgridIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/sendgrid')
            .setRequestSchema(sendgridConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: sendgridConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the SendGrid integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteSendgridIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/sendgrid')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Amazon SES integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SesConfigCollection>>} - OK
     */
    async listSesIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/ses')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: sesConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Amazon SES integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SesConfigPayload>>} - OK
     */
    async saveSesIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/ses')
            .setRequestSchema(sesConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: sesConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Amazon SES integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteSesIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/ses')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Slack integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackConfigCollection>>} - OK
     */
    async listSlackIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/slack')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: slackConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Slack integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackConfigPayload>>} - OK
     */
    async saveSlackIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/slack')
            .setRequestSchema(slackConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: slackConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Slack integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteSlackIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/slack')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current SMTP integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SmtpConfigObjectCollection>>} - OK
     */
    async listSmtpIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/smtp')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: smtpConfigObjectCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the SMTP integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SmtpConfig>>} - OK
     */
    async saveSmtpIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/smtp')
            .setRequestSchema(smtpConfigRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: smtpConfigResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the SMTP integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteSmtpIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/smtp')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Stripe integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<StripeConfigCollection>>} - OK
     */
    async listStripeIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/stripe')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: stripeConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Stripe integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<StripeConfigPayload>>} - OK
     */
    async saveStripeIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/stripe')
            .setRequestSchema(stripeConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: stripeConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Stripe integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteStripeIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/stripe')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Twilio integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<TwilioConfigCollection>>} - OK
     */
    async listTwilioIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/twilio')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: twilioConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Twilio integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<TwilioConfigPayload>>} - OK
     */
    async saveTwilioIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/twilio')
            .setRequestSchema(twilioConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: twilioConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Twilio integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteTwilioIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/twilio')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Web Push integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<WebpushConfigCollection>>} - OK
     */
    async listWebPushIntegrations(requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/web_push')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: webpushConfigCollectionResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Web Push integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<WebpushConfigPayload>>} - OK
     */
    async saveWebPushIntegration(body, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/web_push')
            .setRequestSchema(webpushConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: webpushConfigPayloadResponse,
            contentType: ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Web Push integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteWebPushIntegration(params, requestConfig) {
        const request = new RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/web_push')
            .setRequestSchema(z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(ContentType.Json)
            .addResponse({
            schema: z.undefined(),
            contentType: ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
}
//# sourceMappingURL=integrations-service.js.map