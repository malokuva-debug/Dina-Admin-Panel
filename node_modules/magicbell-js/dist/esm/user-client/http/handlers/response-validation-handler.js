import { ZodUndefined } from 'zod';
import { ContentType } from '../types.js';
import { ResponseMatcher } from '../utils/response-matcher.js';
export class ResponseValidationHandler {
    constructor() {
        Object.defineProperty(this, "next", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    async handle(request) {
        const response = await this.next.handle(request);
        return this.decodeBody(request, response);
    }
    async *stream(request) {
        const stream = this.next.stream(request);
        for await (const response of stream) {
            const responseChunks = this.splitByDataChunks(response);
            for (const chunk of responseChunks) {
                yield this.decodeBody(request, chunk);
            }
        }
    }
    splitByDataChunks(response) {
        var _a;
        if (!((_a = response.metadata.headers['content-type']) === null || _a === void 0 ? void 0 : _a.includes('text/event-stream'))) {
            return [response];
        }
        const text = new TextDecoder().decode(response.raw);
        const encoder = new TextEncoder();
        return text
            .split('\n')
            .filter((line) => line.startsWith('data: '))
            .map((part) => ({
            ...response,
            raw: encoder.encode(part).buffer,
        }));
    }
    decodeBody(request, response) {
        var _a;
        const responseMatcher = new ResponseMatcher(request.responses);
        const responseDefinition = responseMatcher.getResponseDefinition(response);
        if (!responseDefinition || !this.hasContent(responseDefinition, response)) {
            return response;
        }
        const contentType = responseDefinition.contentType;
        const contentTypeHandlers = {
            [ContentType.Binary]: this.decodeFile,
            [ContentType.Image]: this.decodeFile,
            [ContentType.MultipartFormData]: this.decodeMultipartFormData,
            [ContentType.Text]: this.decodeText,
            [ContentType.Xml]: this.decodeText,
            [ContentType.FormUrlEncoded]: this.decodeFormUrlEncoded,
            [ContentType.EventStream]: this.decodeEventStream,
        };
        if (contentTypeHandlers[contentType]) {
            return contentTypeHandlers[contentType].call(this, request, responseDefinition, response);
        }
        if ((_a = response.metadata.headers['content-type']) === null || _a === void 0 ? void 0 : _a.includes('text/event-stream')) {
            return this.decodeEventStream(request, responseDefinition, response);
        }
        return this.decodeJson(request, responseDefinition, response);
    }
    decodeFile(request, responseDefinition, response) {
        return {
            ...response,
            data: this.validate(request, responseDefinition, response.raw),
        };
    }
    decodeMultipartFormData(request, responseDefinition, response) {
        const formData = this.fromFormData(response.raw);
        return {
            ...response,
            data: this.validate(request, responseDefinition, formData),
        };
    }
    decodeText(request, responseDefinition, response) {
        const decodedBody = new TextDecoder().decode(response.raw);
        return {
            ...response,
            data: this.validate(request, responseDefinition, decodedBody),
        };
    }
    decodeFormUrlEncoded(request, responseDefinition, response) {
        const decodedBody = new TextDecoder().decode(response.raw);
        const urlEncoded = this.fromUrlEncoded(decodedBody);
        return {
            ...response,
            data: this.validate(request, responseDefinition, urlEncoded),
        };
    }
    decodeEventStream(request, responseDefinition, response) {
        let decodedBody = new TextDecoder().decode(response.raw);
        if (decodedBody.startsWith('data: ')) {
            decodedBody = decodedBody.substring(6);
        }
        // Note: this assumes that the content of data is a valid JSON string
        const json = JSON.parse(decodedBody);
        return {
            ...response,
            data: this.validate(request, responseDefinition, json),
        };
    }
    decodeJson(request, responseDefinition, response) {
        const decodedBody = new TextDecoder().decode(response.raw);
        const json = JSON.parse(decodedBody);
        return {
            ...response,
            data: this.validate(request, responseDefinition, json),
        };
    }
    validate(request, response, data) {
        var _a;
        if ((_a = request.validation) === null || _a === void 0 ? void 0 : _a.responseValidation) {
            return response.schema.parse(data);
        }
        return data;
    }
    hasContent(responseDefinition, response) {
        return (!!responseDefinition.schema &&
            !(responseDefinition.schema instanceof ZodUndefined) &&
            response.metadata.status !== 204);
    }
    fromUrlEncoded(urlEncodedData) {
        const pairs = urlEncodedData.split('&');
        const result = {};
        pairs.forEach((pair) => {
            const [key, value] = pair.split('=');
            if (key && value !== undefined) {
                result[decodeURIComponent(key)] = decodeURIComponent(value);
            }
        });
        return result;
    }
    fromFormData(arrayBuffer) {
        const decoder = new TextDecoder();
        const text = decoder.decode(arrayBuffer);
        const boundary = text.split('\r\n')[0];
        const parts = text.split(boundary).slice(1, -1);
        const formDataObj = {};
        parts.forEach((part) => {
            const [header, value] = part.split('\r\n\r\n');
            const nameMatch = header.match(/name="([^"]+)"/);
            if (nameMatch) {
                const name = nameMatch[1].trim();
                formDataObj[name] = (value === null || value === void 0 ? void 0 : value.trim()) || '';
            }
        });
        return formDataObj;
    }
}
//# sourceMappingURL=response-validation-handler.js.map