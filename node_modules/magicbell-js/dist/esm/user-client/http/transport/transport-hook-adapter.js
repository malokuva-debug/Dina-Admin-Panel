import { CustomHook } from '../hooks/custom-hook.js';
import { SerializationStyle } from '../serialization/base-serializer.js';
export class TransportHookAdapter {
    constructor() {
        Object.defineProperty(this, "hook", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new CustomHook()
        });
    }
    async beforeRequest(request, params) {
        const hookRequest = this.requestToHookRequest(request);
        const newRequest = await this.hook.beforeRequest(hookRequest, params);
        const newTransportRequest = request.copy({
            baseUrl: newRequest.baseUrl,
            method: newRequest.method,
            path: newRequest.path,
            body: newRequest.body,
            queryParams: this.hookParamsToTransportParams(newRequest.queryParams, request.queryParams, true),
            headers: this.hookParamsToTransportParams(newRequest.headers, request.headers, false),
            pathParams: this.hookParamsToTransportParams(newRequest.pathParams, request.headers, false),
        });
        return newTransportRequest;
    }
    async afterResponse(request, response, params) {
        const hookRequest = this.requestToHookRequest(request);
        return this.hook.afterResponse(hookRequest, response, params);
    }
    async onError(request, response, params) {
        const hookRequest = this.requestToHookRequest(request);
        return this.hook.onError(hookRequest, response, params);
    }
    requestToHookRequest(request) {
        const hookHeaders = new Map();
        request.headers.forEach((header, key) => {
            hookHeaders.set(key, header.value);
        });
        const hookQueryParams = new Map();
        request.queryParams.forEach((queryParam, key) => {
            hookQueryParams.set(key, queryParam.value);
        });
        const hookPathParams = new Map();
        request.pathParams.forEach((pathParam, key) => {
            hookPathParams.set(key, pathParam.value);
        });
        const hookRequest = {
            baseUrl: request.baseUrl,
            method: request.method,
            path: request.path,
            headers: hookHeaders,
            body: request.body,
            queryParams: hookQueryParams,
            pathParams: hookPathParams,
        };
        return hookRequest;
    }
    hookParamsToTransportParams(hookParams, originalTransportParams, encode) {
        const transportParams = new Map();
        hookParams.forEach((hookParamValue, hookParamKey) => {
            var _a, _b, _c, _d, _e;
            const requestParam = originalTransportParams.get(hookParamKey);
            transportParams.set(hookParamKey, {
                key: hookParamKey,
                value: hookParamValue,
                encode: (_a = requestParam === null || requestParam === void 0 ? void 0 : requestParam.encode) !== null && _a !== void 0 ? _a : false,
                style: (requestParam === null || requestParam === void 0 ? void 0 : requestParam.style) || SerializationStyle.NONE,
                explode: (_b = requestParam === null || requestParam === void 0 ? void 0 : requestParam.explode) !== null && _b !== void 0 ? _b : false,
                isLimit: (_c = requestParam === null || requestParam === void 0 ? void 0 : requestParam.isLimit) !== null && _c !== void 0 ? _c : false,
                isOffset: (_d = requestParam === null || requestParam === void 0 ? void 0 : requestParam.isOffset) !== null && _d !== void 0 ? _d : false,
                isCursor: (_e = requestParam === null || requestParam === void 0 ? void 0 : requestParam.isCursor) !== null && _e !== void 0 ? _e : false,
            });
        });
        return transportParams;
    }
}
//# sourceMappingURL=transport-hook-adapter.js.map