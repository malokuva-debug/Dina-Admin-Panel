"use strict";
var _Realtime_instances, _Realtime_client, _Realtime_socketUrl, _Realtime_inboxToken, _Realtime_origin, _Realtime_websocket, _Realtime_isConnected, _Realtime_reconnectAttempts, _Realtime_maxReconnectAttempts, _Realtime_reconnectInterval, _Realtime_notificationHandler, _Realtime_handleMessage, _Realtime_isNewNotificationMessage, _Realtime_handleNewNotification, _Realtime_handleReconnect, _Realtime_getUrl, _Realtime_getToken;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Realtime = void 0;
const tslib_1 = require("tslib");
const user_client_js_1 = require("./user-client.js");
class Realtime {
    constructor(options) {
        _Realtime_instances.add(this);
        _Realtime_client.set(this, void 0);
        _Realtime_socketUrl.set(this, 'wss://ws.magicbell.com');
        _Realtime_inboxToken.set(this, void 0);
        _Realtime_origin.set(this, void 0);
        _Realtime_websocket.set(this, void 0);
        _Realtime_isConnected.set(this, false);
        _Realtime_reconnectAttempts.set(this, 0);
        _Realtime_maxReconnectAttempts.set(this, 5);
        _Realtime_reconnectInterval.set(this, 1000);
        _Realtime_notificationHandler.set(this, void 0);
        if (options instanceof user_client_js_1.Client) {
            tslib_1.__classPrivateFieldSet(this, _Realtime_client, options, "f");
        }
        else {
            tslib_1.__classPrivateFieldSet(this, _Realtime_client, new user_client_js_1.Client({ token: options.token }), "f");
        }
    }
    async listen(onNotification) {
        tslib_1.__classPrivateFieldSet(this, _Realtime_notificationHandler, onNotification, "f");
        if (tslib_1.__classPrivateFieldGet(this, _Realtime_websocket, "f") && tslib_1.__classPrivateFieldGet(this, _Realtime_isConnected, "f")) {
            console.warn('Already connected to WebSocket');
            return;
        }
        try {
            const url = await tslib_1.__classPrivateFieldGet(this, _Realtime_instances, "m", _Realtime_getUrl).call(this);
            tslib_1.__classPrivateFieldSet(this, _Realtime_websocket, new WebSocket(url), "f");
            tslib_1.__classPrivateFieldGet(this, _Realtime_websocket, "f").onopen = () => {
                tslib_1.__classPrivateFieldSet(this, _Realtime_isConnected, true, "f");
                tslib_1.__classPrivateFieldSet(this, _Realtime_reconnectAttempts, 0, "f");
                tslib_1.__classPrivateFieldSet(this, _Realtime_reconnectInterval, 1000, "f");
            };
            tslib_1.__classPrivateFieldGet(this, _Realtime_websocket, "f").onmessage = (event) => {
                if (event.origin !== tslib_1.__classPrivateFieldGet(this, _Realtime_origin, "f"))
                    return;
                try {
                    const data = JSON.parse(event.data);
                    tslib_1.__classPrivateFieldGet(this, _Realtime_instances, "m", _Realtime_handleMessage).call(this, data);
                }
                catch (error) {
                    console.error('Failed to parse WebSocket message:', error);
                }
            };
            tslib_1.__classPrivateFieldGet(this, _Realtime_websocket, "f").onclose = (event) => {
                console.warn('WebSocket disconnected:', event.code, event.reason);
                tslib_1.__classPrivateFieldSet(this, _Realtime_isConnected, false, "f");
                tslib_1.__classPrivateFieldGet(this, _Realtime_instances, "m", _Realtime_handleReconnect).call(this);
            };
            tslib_1.__classPrivateFieldGet(this, _Realtime_websocket, "f").onerror = (error) => {
                console.error('WebSocket error:', error);
                tslib_1.__classPrivateFieldSet(this, _Realtime_isConnected, false, "f");
            };
        }
        catch (error) {
            console.error('Failed to connect to WebSocket:', error);
            tslib_1.__classPrivateFieldGet(this, _Realtime_instances, "m", _Realtime_handleReconnect).call(this);
        }
    }
    disconnect() {
        if (tslib_1.__classPrivateFieldGet(this, _Realtime_websocket, "f")) {
            tslib_1.__classPrivateFieldGet(this, _Realtime_websocket, "f").close();
            tslib_1.__classPrivateFieldSet(this, _Realtime_websocket, undefined, "f");
        }
        tslib_1.__classPrivateFieldSet(this, _Realtime_isConnected, false, "f");
        tslib_1.__classPrivateFieldSet(this, _Realtime_reconnectAttempts, 0, "f");
    }
    isListening() {
        return tslib_1.__classPrivateFieldGet(this, _Realtime_isConnected, "f");
    }
}
exports.Realtime = Realtime;
_Realtime_client = new WeakMap(), _Realtime_socketUrl = new WeakMap(), _Realtime_inboxToken = new WeakMap(), _Realtime_origin = new WeakMap(), _Realtime_websocket = new WeakMap(), _Realtime_isConnected = new WeakMap(), _Realtime_reconnectAttempts = new WeakMap(), _Realtime_maxReconnectAttempts = new WeakMap(), _Realtime_reconnectInterval = new WeakMap(), _Realtime_notificationHandler = new WeakMap(), _Realtime_instances = new WeakSet(), _Realtime_handleMessage = function _Realtime_handleMessage(data) {
    if (!tslib_1.__classPrivateFieldGet(this, _Realtime_instances, "m", _Realtime_isNewNotificationMessage).call(this, data)) {
        return;
    }
    tslib_1.__classPrivateFieldGet(this, _Realtime_instances, "m", _Realtime_handleNewNotification).call(this, data.data.id);
}, _Realtime_isNewNotificationMessage = function _Realtime_isNewNotificationMessage(data) {
    return (typeof data === 'object' &&
        data !== null &&
        data.name === 'notifications/new' &&
        typeof data.data === 'object' &&
        data.data !== null &&
        typeof data.data.id === 'string');
}, _Realtime_handleNewNotification = async function _Realtime_handleNewNotification(notificationId) {
    if (!tslib_1.__classPrivateFieldGet(this, _Realtime_notificationHandler, "f")) {
        console.warn('No notification handler provided');
        return;
    }
    try {
        const { data: notification, metadata: res } = await tslib_1.__classPrivateFieldGet(this, _Realtime_client, "f").notifications.fetchNotification(notificationId);
        if (!isOK(res)) {
            console.error(`Failed to fetch notification ${notificationId}: ${res.status} ${res.statusText}`);
            return;
        }
        if (notification) {
            tslib_1.__classPrivateFieldGet(this, _Realtime_notificationHandler, "f").call(this, notification);
        }
    }
    catch (error) {
        console.error(`Error fetching notification ${notificationId}:`, error);
    }
}, _Realtime_handleReconnect = function _Realtime_handleReconnect() {
    if (tslib_1.__classPrivateFieldGet(this, _Realtime_reconnectAttempts, "f") >= tslib_1.__classPrivateFieldGet(this, _Realtime_maxReconnectAttempts, "f")) {
        console.error('Max reconnection attempts reached');
        return;
    }
    if (!tslib_1.__classPrivateFieldGet(this, _Realtime_notificationHandler, "f")) {
        console.warn('No notification handler, skipping reconnect');
        return;
    }
    setTimeout(() => {
        var _a;
        tslib_1.__classPrivateFieldSet(this, _Realtime_reconnectAttempts, (_a = tslib_1.__classPrivateFieldGet(this, _Realtime_reconnectAttempts, "f"), _a++, _a), "f");
        tslib_1.__classPrivateFieldSet(this, _Realtime_reconnectInterval, Math.min(tslib_1.__classPrivateFieldGet(this, _Realtime_reconnectInterval, "f") * 2, 30000), "f"); // Max 30 seconds
        this.listen(tslib_1.__classPrivateFieldGet(this, _Realtime_notificationHandler, "f"));
    }, tslib_1.__classPrivateFieldGet(this, _Realtime_reconnectInterval, "f"));
}, _Realtime_getUrl = async function _Realtime_getUrl() {
    const jwtToken = tslib_1.__classPrivateFieldGet(this, _Realtime_client, "f").config.token;
    invariant(jwtToken, 'Failed to get token from client');
    const apiKey = getApiKeyFromToken(jwtToken);
    invariant(apiKey, 'Failed to get API key from token');
    const token = await tslib_1.__classPrivateFieldGet(this, _Realtime_instances, "m", _Realtime_getToken).call(this);
    const url = new URL(tslib_1.__classPrivateFieldGet(this, _Realtime_socketUrl, "f"));
    url.searchParams.set('api_key', apiKey);
    url.searchParams.set('token', token);
    tslib_1.__classPrivateFieldSet(this, _Realtime_origin, url.origin, "f");
    return url.toString();
}, _Realtime_getToken = async function _Realtime_getToken() {
    if (tslib_1.__classPrivateFieldGet(this, _Realtime_inboxToken, "f"))
        return tslib_1.__classPrivateFieldGet(this, _Realtime_inboxToken, "f");
    const { data, metadata: res } = await tslib_1.__classPrivateFieldGet(this, _Realtime_client, "f").channels.saveInboxToken({
        token: getSessionId(),
    });
    invariant(isOK(res), `Failed to save Inbox token: ${res.status} ${res.statusText}`);
    invariant(data === null || data === void 0 ? void 0 : data.token, 'Unexpected server response, missing token');
    tslib_1.__classPrivateFieldSet(this, _Realtime_inboxToken, data.token, "f");
    return data.token;
};
function isOK(response) {
    return response.status >= 200 && response.status < 300;
}
function invariant(condition, message) {
    if (!condition) {
        throw new Error(message);
    }
}
function getSessionId() {
    if (typeof sessionStorage === 'undefined') {
        return generateID(64);
    }
    // sessionStorage gets cleared when the page session ends. A page
    // session lasts for as long as the browser is open and survives
    // over page reloads and restores. Opening a page in a new tab or
    // window will cause a new session to be initiated. This gives us
    // a stable ID per tab, and different ID's across tabs.
    const stored = sessionStorage.getItem('magicbell--realtime-token');
    if (stored)
        return stored;
    const id = generateID(64);
    sessionStorage.setItem('magicbell--realtime-token', id);
    return id;
}
function generateID(length = 17) {
    let id = '';
    while (id.length < length) {
        id += getRandomValues();
    }
    return id.substring(0, length);
}
function getApiKeyFromToken(token) {
    const data = getTokenPayload(token);
    if (!data)
        return null;
    if (data.api_key) {
        return data.api_key;
    }
    return null;
}
function getTokenPayload(token) {
    try {
        const [_, payload] = token.split('.');
        const data = JSON.parse(atob(payload));
        return data || null;
    }
    catch (_a) {
        return null;
    }
}
const getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues
    ? () => crypto.getRandomValues(new Uint32Array(1))[0].toString(36)
    : () => Math.random().toString(36).substring(2, 15);
//# sourceMappingURL=realtime.js.map