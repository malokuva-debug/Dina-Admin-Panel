"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelsService = void 0;
const zod_1 = require("zod");
const environment_js_1 = require("../../http/environment.js");
const request_builder_js_1 = require("../../http/transport/request-builder.js");
const types_js_1 = require("../../http/types.js");
const base_service_js_1 = require("../base-service.js");
const apns_token_js_1 = require("./models/apns-token.js");
const apns_token_collection_js_1 = require("./models/apns-token-collection.js");
const category_delivery_config_js_1 = require("./models/category-delivery-config.js");
const discard_result_js_1 = require("./models/discard-result.js");
const expo_token_js_1 = require("./models/expo-token.js");
const expo_token_collection_js_1 = require("./models/expo-token-collection.js");
const fcm_token_js_1 = require("./models/fcm-token.js");
const fcm_token_collection_js_1 = require("./models/fcm-token-collection.js");
const inbox_token_response_js_1 = require("./models/inbox-token-response.js");
const inbox_token_response_collection_js_1 = require("./models/inbox-token-response-collection.js");
const slack_token_js_1 = require("./models/slack-token.js");
const slack_token_collection_js_1 = require("./models/slack-token-collection.js");
const teams_token_js_1 = require("./models/teams-token.js");
const teams_token_collection_js_1 = require("./models/teams-token-collection.js");
const web_push_token_js_1 = require("./models/web-push-token.js");
const web_push_token_collection_js_1 = require("./models/web-push-token-collection.js");
class ChannelsService extends base_service_js_1.BaseService {
    /**
     * Save the channels configuration for a given key.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<CategoryDeliveryConfig>>} - OK
     */
    async saveChannelsConfig(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/channels')
            .setRequestSchema(category_delivery_config_js_1.categoryDeliveryConfigRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: category_delivery_config_js_1.categoryDeliveryConfigResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches the channels config for a given key.
     * @param {string} key -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<CategoryDeliveryConfig>>} - OK
     */
    async fetchChannelsConfig(key, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/{key}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: category_delivery_config_js_1.categoryDeliveryConfigResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'key',
            value: key,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all Inbox tokens associated with a specific user. This endpoint is available to project administrators and returns a paginated list of tokens, including both active and revoked tokens.
     * @param {string} userId -
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<InboxTokenResponseCollection>>} - OK
     */
    async listUserInboxTokens(userId, params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/in_app/inbox/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: inbox_token_response_collection_js_1.inboxTokenResponseCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches a specific Inbox token by its ID for a given user. This endpoint is available to project administrators and requires project-level authentication. Use this to inspect token details including its status, creation date, and associated metadata.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<InboxTokenResponse>>} - OK
     */
    async fetchUserInboxToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/in_app/inbox/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: inbox_token_response_js_1.inboxTokenResponseResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes a specific user's Inbox token. This endpoint is available to project administrators and permanently invalidates the specified token. Once revoked, the token can no longer be used to access channel features. This action cannot be undone.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteUserInboxToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/users/{user_id}/channels/in_app/inbox/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all APNs tokens associated with a specific user. This endpoint is available to project administrators and returns a paginated list of tokens, including both active and revoked tokens.
     * @param {string} userId -
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ApnsTokenCollection>>} - OK
     */
    async listUserApnsTokens(userId, params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/mobile_push/apns/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: apns_token_collection_js_1.apnsTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches a specific APNs token by its ID for a given user. This endpoint is available to project administrators and requires project-level authentication. Use this to inspect token details including its status, creation date, and associated metadata.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ApnsToken>>} - OK
     */
    async fetchUserApnsToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/mobile_push/apns/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: apns_token_js_1.apnsTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes a specific user's APNs token. This endpoint is available to project administrators and permanently invalidates the specified token. Once revoked, the token can no longer be used to access channel features. This action cannot be undone.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteUserApnsToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/users/{user_id}/channels/mobile_push/apns/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all Expo tokens associated with a specific user. This endpoint is available to project administrators and returns a paginated list of tokens, including both active and revoked tokens.
     * @param {string} userId -
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ExpoTokenCollection>>} - OK
     */
    async listUserExpoTokens(userId, params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/mobile_push/expo/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: expo_token_collection_js_1.expoTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches a specific Expo token by its ID for a given user. This endpoint is available to project administrators and requires project-level authentication. Use this to inspect token details including its status, creation date, and associated metadata.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ExpoToken>>} - OK
     */
    async fetchUserExpoToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/mobile_push/expo/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: expo_token_js_1.expoTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes a specific user's Expo token. This endpoint is available to project administrators and permanently invalidates the specified token. Once revoked, the token can no longer be used to access channel features. This action cannot be undone.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteUserExpoToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/users/{user_id}/channels/mobile_push/expo/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all FCM tokens associated with a specific user. This endpoint is available to project administrators and returns a paginated list of tokens, including both active and revoked tokens.
     * @param {string} userId -
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<FcmTokenCollection>>} - OK
     */
    async listUserFcmTokens(userId, params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/mobile_push/fcm/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: fcm_token_collection_js_1.fcmTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches a specific FCM token by its ID for a given user. This endpoint is available to project administrators and requires project-level authentication. Use this to inspect token details including its status, creation date, and associated metadata.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<FcmToken>>} - OK
     */
    async fetchUserFcmToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/mobile_push/fcm/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: fcm_token_js_1.fcmTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes a specific user's FCM token. This endpoint is available to project administrators and permanently invalidates the specified token. Once revoked, the token can no longer be used to access channel features. This action cannot be undone.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteUserFcmToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/users/{user_id}/channels/mobile_push/fcm/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all MagicBell SlackBot tokens associated with a specific user. This endpoint is available to project administrators and returns a paginated list of tokens, including both active and revoked tokens.
     * @param {string} userId -
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackTokenCollection>>} - OK
     */
    async listUserMagicbellSlackbotTokens(userId, params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/slack/magicbell_slackbot/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_token_collection_js_1.slackTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches a specific MagicBell SlackBot token by its ID for a given user. This endpoint is available to project administrators and requires project-level authentication. Use this to inspect token details including its status, creation date, and associated metadata.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackToken>>} - OK
     */
    async fetchUserMagicbellSlackbotToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/slack/magicbell_slackbot/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_token_js_1.slackTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes a specific user's MagicBell SlackBot token. This endpoint is available to project administrators and permanently invalidates the specified token. Once revoked, the token can no longer be used to access channel features. This action cannot be undone.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteUserMagicbellSlackbotToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/users/{user_id}/channels/slack/magicbell_slackbot/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all Slack tokens associated with a specific user. This endpoint is available to project administrators and returns a paginated list of tokens, including both active and revoked tokens.
     * @param {string} userId -
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackTokenCollection>>} - OK
     */
    async listUserSlackTokens(userId, params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/slack/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_token_collection_js_1.slackTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches a specific Slack token by its ID for a given user. This endpoint is available to project administrators and requires project-level authentication. Use this to inspect token details including its status, creation date, and associated metadata.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackToken>>} - OK
     */
    async fetchUserSlackToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/slack/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_token_js_1.slackTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes a specific user's Slack token. This endpoint is available to project administrators and permanently invalidates the specified token. Once revoked, the token can no longer be used to access channel features. This action cannot be undone.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteUserSlackToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/users/{user_id}/channels/slack/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all Teams tokens associated with a specific user. This endpoint is available to project administrators and returns a paginated list of tokens, including both active and revoked tokens.
     * @param {string} userId -
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<TeamsTokenCollection>>} - OK
     */
    async listUserTeamsTokens(userId, params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/teams/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: teams_token_collection_js_1.teamsTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches a specific Teams token by its ID for a given user. This endpoint is available to project administrators and requires project-level authentication. Use this to inspect token details including its status, creation date, and associated metadata.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<TeamsToken>>} - OK
     */
    async fetchUserTeamsToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/teams/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: teams_token_js_1.teamsTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes a specific user's Teams token. This endpoint is available to project administrators and permanently invalidates the specified token. Once revoked, the token can no longer be used to access channel features. This action cannot be undone.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteUserTeamsToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/users/{user_id}/channels/teams/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all Web Push tokens associated with a specific user. This endpoint is available to project administrators and returns a paginated list of tokens, including both active and revoked tokens.
     * @param {string} userId -
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<WebPushTokenCollection>>} - OK
     */
    async listUserWebPushTokens(userId, params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/web_push/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: web_push_token_collection_js_1.webPushTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches a specific Web Push token by its ID for a given user. This endpoint is available to project administrators and requires project-level authentication. Use this to inspect token details including its status, creation date, and associated metadata.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<WebPushToken>>} - OK
     */
    async fetchUserWebPushToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/users/{user_id}/channels/web_push/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: web_push_token_js_1.webPushTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes a specific user's Web Push token. This endpoint is available to project administrators and permanently invalidates the specified token. Once revoked, the token can no longer be used to access channel features. This action cannot be undone.
     * @param {string} userId -
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteUserWebPushToken(userId, tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/users/{user_id}/channels/web_push/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'user_id',
            value: userId,
        })
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
}
exports.ChannelsService = ChannelsService;
//# sourceMappingURL=channels-service.js.map