"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntegrationsService = void 0;
const zod_1 = require("zod");
const environment_js_1 = require("../../http/environment.js");
const request_builder_js_1 = require("../../http/transport/request-builder.js");
const types_js_1 = require("../../http/types.js");
const base_service_js_1 = require("../base-service.js");
const apns_config_collection_js_1 = require("./models/apns-config-collection.js");
const apns_config_payload_js_1 = require("./models/apns-config-payload.js");
const event_source_config_collection_js_1 = require("./models/event-source-config-collection.js");
const event_source_config_payload_js_1 = require("./models/event-source-config-payload.js");
const expo_config_collection_js_1 = require("./models/expo-config-collection.js");
const expo_config_payload_js_1 = require("./models/expo-config-payload.js");
const fcm_config_collection_js_1 = require("./models/fcm-config-collection.js");
const fcm_config_payload_js_1 = require("./models/fcm-config-payload.js");
const github_config_collection_js_1 = require("./models/github-config-collection.js");
const github_config_payload_js_1 = require("./models/github-config-payload.js");
const inbox_config_collection_js_1 = require("./models/inbox-config-collection.js");
const inbox_config_payload_js_1 = require("./models/inbox-config-payload.js");
const integration_config_collection_js_1 = require("./models/integration-config-collection.js");
const mailgun_config_collection_js_1 = require("./models/mailgun-config-collection.js");
const mailgun_config_payload_js_1 = require("./models/mailgun-config-payload.js");
const ping_config_collection_js_1 = require("./models/ping-config-collection.js");
const ping_config_payload_js_1 = require("./models/ping-config-payload.js");
const sendgrid_config_collection_js_1 = require("./models/sendgrid-config-collection.js");
const sendgrid_config_payload_js_1 = require("./models/sendgrid-config-payload.js");
const ses_config_collection_js_1 = require("./models/ses-config-collection.js");
const ses_config_payload_js_1 = require("./models/ses-config-payload.js");
const slack_bot_config_collection_js_1 = require("./models/slack-bot-config-collection.js");
const slack_bot_config_payload_js_1 = require("./models/slack-bot-config-payload.js");
const slack_config_collection_js_1 = require("./models/slack-config-collection.js");
const slack_config_payload_js_1 = require("./models/slack-config-payload.js");
const smtp_config_js_1 = require("./models/smtp-config.js");
const smtp_config_object_collection_js_1 = require("./models/smtp-config-object-collection.js");
const stripe_config_collection_js_1 = require("./models/stripe-config-collection.js");
const stripe_config_payload_js_1 = require("./models/stripe-config-payload.js");
const twilio_config_collection_js_1 = require("./models/twilio-config-collection.js");
const twilio_config_payload_js_1 = require("./models/twilio-config-payload.js");
const webpush_config_collection_js_1 = require("./models/webpush-config-collection.js");
const webpush_config_payload_js_1 = require("./models/webpush-config-payload.js");
class IntegrationsService extends base_service_js_1.BaseService {
    /**
     * Lists all available and configured integrations for the project. Returns a summary of each integration including its type, status, and basic configuration information.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<IntegrationConfigCollection>>} - OK
     */
    async listIntegrations(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: integration_config_collection_js_1.integrationConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current APNs integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ApnsConfigCollection>>} - OK
     */
    async listApnsIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/apns')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: apns_config_collection_js_1.apnsConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the APNs integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ApnsConfigPayload>>} - OK
     */
    async saveApnsIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/apns')
            .setRequestSchema(apns_config_payload_js_1.apnsConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: apns_config_payload_js_1.apnsConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the APNs integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteApnsIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/apns')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current EventSource integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<EventSourceConfigCollection>>} - OK
     */
    async listEventsourceIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/eventsource')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: event_source_config_collection_js_1.eventSourceConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the EventSource integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<EventSourceConfigPayload>>} - OK
     */
    async saveEventsourceIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/eventsource')
            .setRequestSchema(event_source_config_payload_js_1.eventSourceConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: event_source_config_payload_js_1.eventSourceConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the EventSource integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteEventsourceIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/eventsource')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Expo integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ExpoConfigCollection>>} - OK
     */
    async listExpoIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/expo')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: expo_config_collection_js_1.expoConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Expo integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ExpoConfigPayload>>} - OK
     */
    async saveExpoIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/expo')
            .setRequestSchema(expo_config_payload_js_1.expoConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: expo_config_payload_js_1.expoConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Expo integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteExpoIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/expo')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current FCM integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<FcmConfigCollection>>} - OK
     */
    async listFcmIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/fcm')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: fcm_config_collection_js_1.fcmConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the FCM integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<FcmConfigPayload>>} - OK
     */
    async saveFcmIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/fcm')
            .setRequestSchema(fcm_config_payload_js_1.fcmConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: fcm_config_payload_js_1.fcmConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the FCM integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteFcmIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/fcm')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current GitHub integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<GithubConfigCollection>>} - OK
     */
    async listGithubIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/github')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: github_config_collection_js_1.githubConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the GitHub integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<GithubConfigPayload>>} - OK
     */
    async saveGithubIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/github')
            .setRequestSchema(github_config_payload_js_1.githubConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: github_config_payload_js_1.githubConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the GitHub integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteGithubIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/github')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Inbox integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<InboxConfigCollection>>} - OK
     */
    async listInboxIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/inbox')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: inbox_config_collection_js_1.inboxConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Inbox integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<InboxConfigPayload>>} - OK
     */
    async saveInboxIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/inbox')
            .setRequestSchema(inbox_config_payload_js_1.inboxConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: inbox_config_payload_js_1.inboxConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Inbox integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteInboxIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/inbox')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current MagicBell SlackBot integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackBotConfigCollection>>} - OK
     */
    async listMagicbellSlackbotIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/magicbell_slackbot')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_bot_config_collection_js_1.slackBotConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the MagicBell SlackBot integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackBotConfigPayload>>} - OK
     */
    async saveMagicbellSlackbotIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/magicbell_slackbot')
            .setRequestSchema(slack_bot_config_payload_js_1.slackBotConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_bot_config_payload_js_1.slackBotConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the MagicBell SlackBot integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteMagicbellSlackbotIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/magicbell_slackbot')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Mailgun integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<MailgunConfigCollection>>} - OK
     */
    async listMailgunIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/mailgun')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: mailgun_config_collection_js_1.mailgunConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Mailgun integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<MailgunConfigPayload>>} - OK
     */
    async saveMailgunIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/mailgun')
            .setRequestSchema(mailgun_config_payload_js_1.mailgunConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: mailgun_config_payload_js_1.mailgunConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Mailgun integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteMailgunIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/mailgun')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Ping Email integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<PingConfigCollection>>} - OK
     */
    async listPingEmailIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/ping_email')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: ping_config_collection_js_1.pingConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Ping Email integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<PingConfigPayload>>} - OK
     */
    async savePingEmailIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/ping_email')
            .setRequestSchema(ping_config_payload_js_1.pingConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: ping_config_payload_js_1.pingConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Ping Email integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deletePingEmailIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/ping_email')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current SendGrid integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SendgridConfigCollection>>} - OK
     */
    async listSendgridIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/sendgrid')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: sendgrid_config_collection_js_1.sendgridConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the SendGrid integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SendgridConfigPayload>>} - OK
     */
    async saveSendgridIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/sendgrid')
            .setRequestSchema(sendgrid_config_payload_js_1.sendgridConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: sendgrid_config_payload_js_1.sendgridConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the SendGrid integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteSendgridIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/sendgrid')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Amazon SES integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SesConfigCollection>>} - OK
     */
    async listSesIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/ses')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: ses_config_collection_js_1.sesConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Amazon SES integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SesConfigPayload>>} - OK
     */
    async saveSesIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/ses')
            .setRequestSchema(ses_config_payload_js_1.sesConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: ses_config_payload_js_1.sesConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Amazon SES integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteSesIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/ses')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Slack integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackConfigCollection>>} - OK
     */
    async listSlackIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/slack')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_config_collection_js_1.slackConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Slack integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackConfigPayload>>} - OK
     */
    async saveSlackIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/slack')
            .setRequestSchema(slack_config_payload_js_1.slackConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_config_payload_js_1.slackConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Slack integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteSlackIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/slack')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current SMTP integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SmtpConfigObjectCollection>>} - OK
     */
    async listSmtpIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/smtp')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: smtp_config_object_collection_js_1.smtpConfigObjectCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the SMTP integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SmtpConfig>>} - OK
     */
    async saveSmtpIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/smtp')
            .setRequestSchema(smtp_config_js_1.smtpConfigRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: smtp_config_js_1.smtpConfigResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the SMTP integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteSmtpIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/smtp')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Stripe integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<StripeConfigCollection>>} - OK
     */
    async listStripeIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/stripe')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: stripe_config_collection_js_1.stripeConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Stripe integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<StripeConfigPayload>>} - OK
     */
    async saveStripeIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/stripe')
            .setRequestSchema(stripe_config_payload_js_1.stripeConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: stripe_config_payload_js_1.stripeConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Stripe integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteStripeIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/stripe')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Twilio integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<TwilioConfigCollection>>} - OK
     */
    async listTwilioIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/twilio')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: twilio_config_collection_js_1.twilioConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Twilio integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<TwilioConfigPayload>>} - OK
     */
    async saveTwilioIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/twilio')
            .setRequestSchema(twilio_config_payload_js_1.twilioConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: twilio_config_payload_js_1.twilioConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Twilio integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteTwilioIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/twilio')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Retrieves the current Web Push integration configurations for a specific integration type in the project. Returns configuration details and status information.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<WebpushConfigCollection>>} - OK
     */
    async listWebPushIntegrations(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/integrations/web_push')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: webpush_config_collection_js_1.webpushConfigCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Updates or creates the Web Push integration for the project.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<WebpushConfigPayload>>} - OK
     */
    async saveWebPushIntegration(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/integrations/web_push')
            .setRequestSchema(webpush_config_payload_js_1.webpushConfigPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: webpush_config_payload_js_1.webpushConfigPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes the Web Push integration configuration from the project. This will disable the integration's functionality within the project.
     * @param {string} [params.id] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async deleteWebPushIntegration(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/integrations/web_push')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'id',
            value: params === null || params === void 0 ? void 0 : params.id,
        })
            .build();
        return this.client.call(request);
    }
}
exports.IntegrationsService = IntegrationsService;
//# sourceMappingURL=integrations-service.js.map