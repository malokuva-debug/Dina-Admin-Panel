"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NotificationsService = void 0;
const zod_1 = require("zod");
const environment_js_1 = require("../../http/environment.js");
const request_builder_js_1 = require("../../http/transport/request-builder.js");
const types_js_1 = require("../../http/types.js");
const base_service_js_1 = require("../base-service.js");
const notification_js_1 = require("./models/notification.js");
const notification_collection_js_1 = require("./models/notification-collection.js");
class NotificationsService extends base_service_js_1.BaseService {
    /**
     * Lists all notifications for a user.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {string} [params.status] -
     * @param {string} [params.category] -
     * @param {string} [params.topic] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<NotificationCollection>>} - OK
     */
    async listNotifications(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/notifications')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: notification_collection_js_1.notificationCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .addQueryParam({
            key: 'status',
            value: params === null || params === void 0 ? void 0 : params.status,
        })
            .addQueryParam({
            key: 'category',
            value: params === null || params === void 0 ? void 0 : params.category,
        })
            .addQueryParam({
            key: 'topic',
            value: params === null || params === void 0 ? void 0 : params.topic,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Archive all notifications.
     * @param {string} [params.category] -
     * @param {string} [params.topic] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async archiveAllNotifications(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('POST')
            .setPath('/notifications/archive')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'category',
            value: params === null || params === void 0 ? void 0 : params.category,
        })
            .addQueryParam({
            key: 'topic',
            value: params === null || params === void 0 ? void 0 : params.topic,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Marks all notifications as read.
     * @param {string} [params.category] -
     * @param {string} [params.topic] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async markAllNotificationsRead(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('POST')
            .setPath('/notifications/read')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'category',
            value: params === null || params === void 0 ? void 0 : params.category,
        })
            .addQueryParam({
            key: 'topic',
            value: params === null || params === void 0 ? void 0 : params.topic,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Gets a notification by ID.
     * @param {string} notificationId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<Notification>>} - OK
     */
    async fetchNotification(notificationId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/notifications/{notification_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: notification_js_1.notificationResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'notification_id',
            value: notificationId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Archive a notification.
     * @param {string} notificationId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async archiveNotification(notificationId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('POST')
            .setPath('/notifications/{notification_id}/archive')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'notification_id',
            value: notificationId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Marks a notification as read.
     * @param {string} notificationId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async markNotificationRead(notificationId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('POST')
            .setPath('/notifications/{notification_id}/read')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'notification_id',
            value: notificationId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Unarchives a notification.
     * @param {string} notificationId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async unarchiveNotification(notificationId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('POST')
            .setPath('/notifications/{notification_id}/unarchive')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'notification_id',
            value: notificationId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Marks a notification as unread.
     * @param {string} notificationId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async markNotificationUnread(notificationId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('POST')
            .setPath('/notifications/{notification_id}/unread')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'notification_id',
            value: notificationId,
        })
            .build();
        return this.client.call(request);
    }
}
exports.NotificationsService = NotificationsService;
//# sourceMappingURL=notifications-service.js.map