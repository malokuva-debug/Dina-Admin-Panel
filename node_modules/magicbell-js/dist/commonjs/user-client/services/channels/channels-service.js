"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChannelsService = void 0;
const zod_1 = require("zod");
const environment_js_1 = require("../../http/environment.js");
const request_builder_js_1 = require("../../http/transport/request-builder.js");
const types_js_1 = require("../../http/types.js");
const base_service_js_1 = require("../base-service.js");
const web_push_token_payload_js_1 = require("../common/web-push-token-payload.js");
const apns_token_js_1 = require("./models/apns-token.js");
const apns_token_collection_js_1 = require("./models/apns-token-collection.js");
const apns_token_payload_js_1 = require("./models/apns-token-payload.js");
const discard_result_js_1 = require("./models/discard-result.js");
const expo_token_js_1 = require("./models/expo-token.js");
const expo_token_collection_js_1 = require("./models/expo-token-collection.js");
const expo_token_payload_js_1 = require("./models/expo-token-payload.js");
const fcm_token_js_1 = require("./models/fcm-token.js");
const fcm_token_collection_js_1 = require("./models/fcm-token-collection.js");
const fcm_token_payload_js_1 = require("./models/fcm-token-payload.js");
const inbox_token_js_1 = require("./models/inbox-token.js");
const inbox_token_response_js_1 = require("./models/inbox-token-response.js");
const inbox_token_response_collection_js_1 = require("./models/inbox-token-response-collection.js");
const slack_token_js_1 = require("./models/slack-token.js");
const slack_token_collection_js_1 = require("./models/slack-token-collection.js");
const slack_token_payload_js_1 = require("./models/slack-token-payload.js");
const teams_token_js_1 = require("./models/teams-token.js");
const teams_token_collection_js_1 = require("./models/teams-token-collection.js");
const teams_token_payload_js_1 = require("./models/teams-token-payload.js");
const user_preferences_js_1 = require("./models/user-preferences.js");
const web_push_token_js_1 = require("./models/web-push-token.js");
const web_push_token_collection_js_1 = require("./models/web-push-token-collection.js");
class ChannelsService extends base_service_js_1.BaseService {
    /**
     * Lists all Inbox tokens belonging to the authenticated user. Returns a paginated list of tokens, including their status, creation dates, and associated metadata.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<InboxTokenResponseCollection>>} - OK
     */
    async listInboxTokens(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/in_app/inbox/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: inbox_token_response_collection_js_1.inboxTokenResponseCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Saves the Inbox token for the authenticated user. This token serves as a credential for accessing channel-specific functionality. Each token is unique to the user and channel combination, allowing for direct communication with the user via the channel.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<InboxToken>>} - OK
     */
    async saveInboxToken(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/channels/in_app/inbox/tokens')
            .setRequestSchema(inbox_token_js_1.inboxTokenRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: inbox_token_js_1.inboxTokenResponse1,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches details of a specific Inbox token belonging to the authenticated user. Returns information about the token's status, creation date, and any associated metadata. Users can only access their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<InboxTokenResponse>>} - OK
     */
    async fetchInboxToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/in_app/inbox/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: inbox_token_response_js_1.inboxTokenResponseResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes one of the authenticated user's Inbox tokens. This permanently invalidates the specified token, preventing it from being used for future channel access. This action cannot be undone. Users can only revoke their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteInboxToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/channels/in_app/inbox/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all APNs tokens belonging to the authenticated user. Returns a paginated list of tokens, including their status, creation dates, and associated metadata.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ApnsTokenCollection>>} - OK
     */
    async listApnsTokens(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/mobile_push/apns/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: apns_token_collection_js_1.apnsTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Saves the APNs token for the authenticated user. This token serves as a credential for accessing channel-specific functionality. Each token is unique to the user and channel combination, allowing for direct communication with the user via the channel.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ApnsTokenPayload>>} - OK
     */
    async saveApnsToken(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/channels/mobile_push/apns/tokens')
            .setRequestSchema(apns_token_payload_js_1.apnsTokenPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: apns_token_payload_js_1.apnsTokenPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches details of a specific APNs token belonging to the authenticated user. Returns information about the token's status, creation date, and any associated metadata. Users can only access their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ApnsToken>>} - OK
     */
    async fetchApnsToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/mobile_push/apns/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: apns_token_js_1.apnsTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes one of the authenticated user's APNs tokens. This permanently invalidates the specified token, preventing it from being used for future channel access. This action cannot be undone. Users can only revoke their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteApnsToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/channels/mobile_push/apns/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all Expo tokens belonging to the authenticated user. Returns a paginated list of tokens, including their status, creation dates, and associated metadata.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ExpoTokenCollection>>} - OK
     */
    async listExpoTokens(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/mobile_push/expo/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: expo_token_collection_js_1.expoTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Saves the Expo token for the authenticated user. This token serves as a credential for accessing channel-specific functionality. Each token is unique to the user and channel combination, allowing for direct communication with the user via the channel.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ExpoTokenPayload>>} - OK
     */
    async saveExpoToken(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/channels/mobile_push/expo/tokens')
            .setRequestSchema(expo_token_payload_js_1.expoTokenPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: expo_token_payload_js_1.expoTokenPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches details of a specific Expo token belonging to the authenticated user. Returns information about the token's status, creation date, and any associated metadata. Users can only access their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<ExpoToken>>} - OK
     */
    async fetchExpoToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/mobile_push/expo/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: expo_token_js_1.expoTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes one of the authenticated user's Expo tokens. This permanently invalidates the specified token, preventing it from being used for future channel access. This action cannot be undone. Users can only revoke their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteExpoToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/channels/mobile_push/expo/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all FCM tokens belonging to the authenticated user. Returns a paginated list of tokens, including their status, creation dates, and associated metadata.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<FcmTokenCollection>>} - OK
     */
    async listFcmTokens(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/mobile_push/fcm/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: fcm_token_collection_js_1.fcmTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Saves the FCM token for the authenticated user. This token serves as a credential for accessing channel-specific functionality. Each token is unique to the user and channel combination, allowing for direct communication with the user via the channel.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<FcmTokenPayload>>} - OK
     */
    async saveFcmToken(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/channels/mobile_push/fcm/tokens')
            .setRequestSchema(fcm_token_payload_js_1.fcmTokenPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: fcm_token_payload_js_1.fcmTokenPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches details of a specific FCM token belonging to the authenticated user. Returns information about the token's status, creation date, and any associated metadata. Users can only access their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<FcmToken>>} - OK
     */
    async fetchFcmToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/mobile_push/fcm/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: fcm_token_js_1.fcmTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes one of the authenticated user's FCM tokens. This permanently invalidates the specified token, preventing it from being used for future channel access. This action cannot be undone. Users can only revoke their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteFcmToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/channels/mobile_push/fcm/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all MagicBell SlackBot tokens belonging to the authenticated user. Returns a paginated list of tokens, including their status, creation dates, and associated metadata.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackTokenCollection>>} - OK
     */
    async listMagicbellSlackbotTokens(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/slack/magicbell_slackbot/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_token_collection_js_1.slackTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Saves the MagicBell SlackBot token for the authenticated user. This token serves as a credential for accessing channel-specific functionality. Each token is unique to the user and channel combination, allowing for direct communication with the user via the channel.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackTokenPayload>>} - OK
     */
    async saveMagicbellSlackbotToken(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/channels/slack/magicbell_slackbot/tokens')
            .setRequestSchema(slack_token_payload_js_1.slackTokenPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_token_payload_js_1.slackTokenPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches details of a specific MagicBell SlackBot token belonging to the authenticated user. Returns information about the token's status, creation date, and any associated metadata. Users can only access their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackToken>>} - OK
     */
    async fetchMagicbellSlackbotToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/slack/magicbell_slackbot/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_token_js_1.slackTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes one of the authenticated user's MagicBell SlackBot tokens. This permanently invalidates the specified token, preventing it from being used for future channel access. This action cannot be undone. Users can only revoke their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteMagicbellSlackbotToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/channels/slack/magicbell_slackbot/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all Slack tokens belonging to the authenticated user. Returns a paginated list of tokens, including their status, creation dates, and associated metadata.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackTokenCollection>>} - OK
     */
    async listSlackTokens(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/slack/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_token_collection_js_1.slackTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Saves the Slack token for the authenticated user. This token serves as a credential for accessing channel-specific functionality. Each token is unique to the user and channel combination, allowing for direct communication with the user via the channel.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackTokenPayload>>} - OK
     */
    async saveSlackToken(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/channels/slack/tokens')
            .setRequestSchema(slack_token_payload_js_1.slackTokenPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_token_payload_js_1.slackTokenPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches details of a specific Slack token belonging to the authenticated user. Returns information about the token's status, creation date, and any associated metadata. Users can only access their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<SlackToken>>} - OK
     */
    async fetchSlackToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/slack/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: slack_token_js_1.slackTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes one of the authenticated user's Slack tokens. This permanently invalidates the specified token, preventing it from being used for future channel access. This action cannot be undone. Users can only revoke their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteSlackToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/channels/slack/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all Teams tokens belonging to the authenticated user. Returns a paginated list of tokens, including their status, creation dates, and associated metadata.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<TeamsTokenCollection>>} - OK
     */
    async listTeamsTokens(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/teams/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: teams_token_collection_js_1.teamsTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Saves the Teams token for the authenticated user. This token serves as a credential for accessing channel-specific functionality. Each token is unique to the user and channel combination, allowing for direct communication with the user via the channel.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<TeamsTokenPayload>>} - OK
     */
    async saveTeamsToken(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/channels/teams/tokens')
            .setRequestSchema(teams_token_payload_js_1.teamsTokenPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: teams_token_payload_js_1.teamsTokenPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches details of a specific Teams token belonging to the authenticated user. Returns information about the token's status, creation date, and any associated metadata. Users can only access their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<TeamsToken>>} - OK
     */
    async fetchTeamsToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/teams/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: teams_token_js_1.teamsTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes one of the authenticated user's Teams tokens. This permanently invalidates the specified token, preventing it from being used for future channel access. This action cannot be undone. Users can only revoke their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteTeamsToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/channels/teams/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Fetch a user's channel delivery preferences.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<UserPreferences>>} - OK
     */
    async fetchUserPreferences(requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/user_preferences')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: user_preferences_js_1.userPreferencesResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .build();
        return this.client.call(request);
    }
    /**
     * Save a user's channel preferences.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<any>>} - No Content
     */
    async saveUserPreferences(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/channels/user_preferences')
            .setRequestSchema(user_preferences_js_1.userPreferencesRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: zod_1.z.undefined(),
            contentType: types_js_1.ContentType.NoContent,
            status: 204,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Lists all Web Push tokens belonging to the authenticated user. Returns a paginated list of tokens, including their status, creation dates, and associated metadata.
     * @param {number} [params.limit] -
     * @param {string} [params.startingAfter] -
     * @param {string} [params.endingBefore] -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<WebPushTokenCollection>>} - OK
     */
    async listWebPushTokens(params, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/web_push/tokens')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: web_push_token_collection_js_1.webPushTokenCollectionResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addQueryParam({
            key: 'limit',
            value: params === null || params === void 0 ? void 0 : params.limit,
        })
            .addQueryParam({
            key: 'starting_after',
            value: params === null || params === void 0 ? void 0 : params.startingAfter,
        })
            .addQueryParam({
            key: 'ending_before',
            value: params === null || params === void 0 ? void 0 : params.endingBefore,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Saves the Web Push token for the authenticated user. This token serves as a credential for accessing channel-specific functionality. Each token is unique to the user and channel combination, allowing for direct communication with the user via the channel.
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<WebPushTokenPayload>>} - OK
     */
    async saveWebPushToken(body, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('PUT')
            .setPath('/channels/web_push/tokens')
            .setRequestSchema(web_push_token_payload_js_1.webPushTokenPayloadRequest)
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: web_push_token_payload_js_1.webPushTokenPayloadResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addHeaderParam({ key: 'Content-Type', value: 'application/json' })
            .addBody(body)
            .build();
        return this.client.call(request);
    }
    /**
     * Fetches details of a specific Web Push token belonging to the authenticated user. Returns information about the token's status, creation date, and any associated metadata. Users can only access their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<WebPushToken>>} - OK
     */
    async fetchWebPushToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('GET')
            .setPath('/channels/web_push/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: web_push_token_js_1.webPushTokenResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
    /**
     * Deletes one of the authenticated user's Web Push tokens. This permanently invalidates the specified token, preventing it from being used for future channel access. This action cannot be undone. Users can only revoke their own tokens.
     * @param {string} tokenId -
     * @param {RequestConfig} [requestConfig] - The request configuration for retry and validation.
     * @returns {Promise<HttpResponse<DiscardResult>>} - OK
     */
    async deleteWebPushToken(tokenId, requestConfig) {
        const request = new request_builder_js_1.RequestBuilder()
            .setBaseUrl((requestConfig === null || requestConfig === void 0 ? void 0 : requestConfig.baseUrl) || this.config.baseUrl || this.config.environment || environment_js_1.Environment.DEFAULT)
            .setConfig(this.config)
            .setMethod('DELETE')
            .setPath('/channels/web_push/tokens/{token_id}')
            .setRequestSchema(zod_1.z.any())
            .addAccessTokenAuth(this.config.token, 'Bearer')
            .setRequestContentType(types_js_1.ContentType.Json)
            .addResponse({
            schema: discard_result_js_1.discardResultResponse,
            contentType: types_js_1.ContentType.Json,
            status: 200,
        })
            .setRetryAttempts(this.config, requestConfig)
            .setRetryDelayMs(this.config, requestConfig)
            .setResponseValidation(this.config, requestConfig)
            .addPathParam({
            key: 'token_id',
            value: tokenId,
        })
            .build();
        return this.client.call(request);
    }
}
exports.ChannelsService = ChannelsService;
//# sourceMappingURL=channels-service.js.map