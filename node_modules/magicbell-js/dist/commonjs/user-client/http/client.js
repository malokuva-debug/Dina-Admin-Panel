"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HttpClient = void 0;
const handler_chain_js_1 = require("./handlers/handler-chain.js");
const hook_handler_js_1 = require("./handlers/hook-handler.js");
const request_validation_handler_js_1 = require("./handlers/request-validation-handler.js");
const response_validation_handler_js_1 = require("./handlers/response-validation-handler.js");
const retry_handler_js_1 = require("./handlers/retry-handler.js");
const terminating_handler_js_1 = require("./handlers/terminating-handler.js");
const custom_hook_js_1 = require("./hooks/custom-hook.js");
const types_js_1 = require("./transport/types.js");
class HttpClient {
    constructor(config, hook = new custom_hook_js_1.CustomHook()) {
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: config
        });
        Object.defineProperty(this, "requestHandlerChain", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new handler_chain_js_1.RequestHandlerChain()
        });
        this.requestHandlerChain.addHandler(new response_validation_handler_js_1.ResponseValidationHandler());
        this.requestHandlerChain.addHandler(new request_validation_handler_js_1.RequestValidationHandler());
        this.requestHandlerChain.addHandler(new retry_handler_js_1.RetryHandler());
        this.requestHandlerChain.addHandler(new hook_handler_js_1.HookHandler(hook));
        this.requestHandlerChain.addHandler(new terminating_handler_js_1.TerminatingHandler());
    }
    call(request) {
        return this.requestHandlerChain.callChain(request);
    }
    async *stream(request) {
        yield* this.requestHandlerChain.streamChain(request);
    }
    async callPaginated(request) {
        const response = await this.call(request);
        if (!response.data) {
            throw new Error('no response data to paginate through');
        }
        const page = this.getPage(request, response.data);
        return {
            ...response,
            data: page,
        };
    }
    async callCursorPaginated(request) {
        const response = await this.call(request);
        if (!response.data) {
            throw new Error('no response data to paginate through');
        }
        const page = this.getPage(request, response.data);
        const nextCursor = this.getNextCursor(request, response.data);
        return {
            ...response,
            data: page,
            nextCursor,
        };
    }
    setBaseUrl(url) {
        this.config.baseUrl = url;
    }
    setConfig(config) {
        this.config = config;
    }
    getPage(request, data) {
        var _a;
        if (!request.pagination) {
            throw new Error('getPage called for request without pagination property');
        }
        let curr = data;
        for (const segment of request.pagination.pagePath || []) {
            curr = curr[segment];
        }
        const page = (_a = request.pagination.pageSchema) === null || _a === void 0 ? void 0 : _a.parse(curr);
        if (!page) {
            throw new Error(`error getting page data. Curr: ${JSON.stringify(curr)}. PagePath: ${request.pagination.pagePath}. Data: ${JSON.stringify(data)}`);
        }
        return page;
    }
    getNextCursor(request, data) {
        var _a, _b;
        if (!(0, types_js_1.isRequestCursorPagination)(request.pagination)) {
            return undefined;
        }
        let curr = data;
        for (const segment of request.pagination.cursorPath) {
            if (curr === null || curr === undefined) {
                return null;
            }
            curr = curr[segment];
        }
        return (_b = (_a = request.pagination.cursorSchema) === null || _a === void 0 ? void 0 : _a.parse(curr)) !== null && _b !== void 0 ? _b : null;
    }
}
exports.HttpClient = HttpClient;
//# sourceMappingURL=client.js.map