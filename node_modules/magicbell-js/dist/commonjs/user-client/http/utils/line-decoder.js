"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineDecoder = void 0;
class LineDecoder {
    constructor() {
        Object.defineProperty(this, "lineBuffer", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ''
        });
        Object.defineProperty(this, "decoder", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new TextDecoder()
        });
        Object.defineProperty(this, "encoder", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new TextEncoder()
        });
    }
    /**
     * Splits the given chunk into lines.
     * Stores incomplete lines in a buffer and returns them when the next chunk arrives.
     */
    splitLines(chunk) {
        this.lineBuffer += this.decoder.decode(chunk);
        let lineEndIndex;
        const lines = [];
        while ((lineEndIndex = this.lineBuffer.indexOf('\n')) >= 0) {
            const line = this.lineBuffer.slice(0, lineEndIndex + 1); // Include the newline character
            this.lineBuffer = this.lineBuffer.slice(lineEndIndex + 1);
            if (line.length > 1) {
                lines.push(this.encoder.encode(line));
            }
        }
        return lines;
    }
    /** Returns the remaining lines in the buffer. */
    flush() {
        if (this.lineBuffer.length === 0) {
            return [];
        }
        const lines = [this.encoder.encode(this.lineBuffer)];
        this.lineBuffer = '';
        return lines;
    }
}
exports.LineDecoder = LineDecoder;
//# sourceMappingURL=line-decoder.js.map