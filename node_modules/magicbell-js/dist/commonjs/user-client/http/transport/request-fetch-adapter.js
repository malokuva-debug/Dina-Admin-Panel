"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestFetchAdapter = void 0;
const error_js_1 = require("../error.js");
const line_decoder_js_1 = require("../utils/line-decoder.js");
class RequestFetchAdapter {
    constructor(request) {
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: request
        });
        Object.defineProperty(this, "requestInit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        this.setMethod(request.method);
        this.setHeaders(request.getHeaders());
        this.setBody(request.body);
        this.setTimeout(request.config.timeoutMs);
    }
    async send() {
        const response = await fetch(this.request.constructFullUrl(), this.requestInit);
        const metadata = {
            status: response.status,
            statusText: response.statusText || '',
            headers: this.getHeaders(response),
        };
        return {
            metadata,
            raw: await response.clone().arrayBuffer(),
        };
    }
    async *stream() {
        const response = await fetch(this.request.constructFullUrl(), this.requestInit);
        const metadata = {
            status: response.status,
            statusText: response.statusText || '',
            headers: this.getHeaders(response),
        };
        if (response.status >= 400) {
            throw new error_js_1.HttpError(metadata, await response.clone().arrayBuffer());
        }
        if (!response.body) {
            return yield {
                metadata,
                raw: await response.clone().arrayBuffer(),
            };
        }
        const reader = response.body.getReader();
        const lineDecoder = new line_decoder_js_1.LineDecoder();
        while (true) {
            const { done, value } = await reader.read();
            if (done) {
                break;
            }
            for (const line of lineDecoder.splitLines(value)) {
                yield {
                    metadata,
                    raw: this.toArrayBuffer(line),
                };
            }
        }
        for (const line of lineDecoder.flush()) {
            yield {
                metadata,
                raw: this.toArrayBuffer(line),
            };
        }
    }
    setMethod(method) {
        if (!method) {
            return;
        }
        this.requestInit = {
            ...this.requestInit,
            method,
        };
    }
    setBody(body) {
        if (!body) {
            return;
        }
        this.requestInit = {
            ...this.requestInit,
            body,
        };
    }
    setHeaders(headers) {
        if (!headers) {
            return;
        }
        this.requestInit = {
            ...this.requestInit,
            headers,
        };
    }
    setTimeout(timeoutMs) {
        if (!timeoutMs) {
            return;
        }
        this.requestInit = {
            ...this.requestInit,
            signal: AbortSignal.timeout(timeoutMs),
        };
    }
    getHeaders(response) {
        const headers = {};
        response.headers.forEach((value, key) => {
            headers[key] = value;
        });
        return headers;
    }
    toArrayBuffer(uint8Array) {
        return uint8Array.buffer.slice(uint8Array.byteOffset, uint8Array.byteOffset + uint8Array.byteLength);
    }
}
exports.RequestFetchAdapter = RequestFetchAdapter;
//# sourceMappingURL=request-fetch-adapter.js.map